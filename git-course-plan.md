# Какво е Configuration Management

Процес следящ конфигурациите на отделните компонентите на една IT система.
Тези компоненти могат да бъдат както код, данни, документация, хардуер, среди,
така и инструментите и стратегиите за тяхната поддръжка.
Системите за контрол на версиите са удобен инструмент с който да се следят
промените по конфигурацията във времето.

Процесът по управление на конфигурациите може да включва:
* Анализ и планиране на необходимите ресурси и инструменти
* Подготовка и поддръжка на среди и конфигурации
* Налагане на стандарти и контрол над данни, документация и код
* Системи за контрол на версиите и стратегии за тяхното използване
* Build and Deploy конфигурации
* Тестване и одити
* Поддръжка на издаден софтуер и преизползване на компоненти

https://www.atlassian.com/microservices/microservices-architecture/configuration-management

# Въведение в системите за контрол на версиите и Гит

Системата за контрол на версиите е средство за проследяване промени по
файловете във времето.

Тя позволява:

1. Възстановяване на файл или цял проект до предишно състояние
2. Сравняване на промени във времето
3. Проследяване кой и кога е направил промени

Видове системи:

1. Централизирани
    - Файловете и историята се пазят на сървър
    - Потребителя тегли работно копие на файловете и качва промени
    - При проблем със сървъра може да бъде загубена цялата история
    - Всяка промяна изисква комуникация със сървъра
2. Разпределени
    - Файловете и историята се пазят на сървъра и при всеки потребител
    - Потребителя синхронизира историята на своето хранилище с тази на сървъра
    - Историята е налична офлайн
    - Командите се изпълняват по-бързо, тъй като се изпълняват локално
    - Разпределените системи са малко по-трудни за научаване

**Без значение от вида система, преди да добавяме своите промени към сървъра,
трябва да изтеглим потенциалните промените от сървъра.**

Гит е разпределена система за контрол на версиите с отворен код. Началото ѝ е
поставено от Линус Торвалдс, създателят на линукс, през 2005-та година.
За разлика от други системи за контрол на версиите, които възприемат
информацията като базови файлове и списък от промени върху тях, Гит гледа на
данните като на колекция от снимки. При всеки комит се качва нова версия на
променените файлове. Едно от най-големите предимства на Гит е възможността за
работа офлайн и лесното разклоняване. Гит, също така, е най-използваната и
най-обсъждана система за контрол на версиите, което улеснява научаването ѝ и
работата с нея.

https://git-scm.com/book/bg/v2

# Задачи

## 1.Създаване на хранилище, клониране на съществуващо хранилище

Инициализира се ново хранилище в текущата папка и се проверява неговото
състояние с командите:

```shell
git init
git status -s
```

Когато се инициализира ново хранилище, се създава и основен клон за него.
По подразбиране гит кръщава този клон `master`. Новата конвенция следвана от
GitHub е този клон да се казва `main`. Можем да сменим името на основния клон,
както и да зададем име по подразбиране за всяко ново хранилище с командите:

```shell
git branch -M main
git config --global init.defaultBranch main
```

Две полезни настройки са:

```shell
# Set VS Code as the editor for commit messages
git config --global core.editor "code --wait"
# Give Git output pretty colors :)
git config --global color.ui auto
```

```shell
git config --global user.name "Вашите Имена" 
git config --global user.email вашиятАкаунт@technologica.com 
git config --global diff.tool vscode 
git config --global difftool.vscode.cmd 'code --wait --diff $LOCAL $REMOTE' 
```

Списък с настройките и тяхната локация се извежда с команда:

```shell
git config --list --show-origin
```

Съществуващо хранилище се клонира от сървъра с команда:

```shell
git clone <адрес-на-хранилището>
```

Какво се промени, с какво хранилището е различно от обикновена папка?  
Можем ли да унищожим хранилището без да загубим файловете?

## Добавяне на файлове и промени, създаване на комит, състояния на файл

Команди за това упражнение:

```shell
git add
git commit
git log
git diff
```

Състояния на файл:
1. Untracked - Нов файл добавен към работната област
2. Modified - Файл с нови промени в работната област
3. Staged - Файл чийто промени са маркирани/индексирани за следващия комит
4. Committed - Файл чието моментно състояние е било запазено в комит

Добавете името си към списъка в `.md` файла!  

Добавете нов текстови файл `<вашето-име>.txt` в същата директория!  
Създайте два отделни комита за горните промени с добри коментари, използвайки
`git commit -m "<вашият-коментар>"` и само `git commit`!  

## Синхронизация със сървъра

Команди за това упражнение:

```shell
git fetch
git pull
git push
```

Качете комита си на сървъра!

## Разклоняване

Команди за това упражнение:

```shell
git branch
git checkout
```

Създайте нов клон `вашето-име` и превключете към него!

## Премахване на файлове, игнориране на файлове

`git rm`
`.gitignore`

https://www.atlassian.com/git/tutorials/saving-changes/gitignore

Премахнете всички `.txt` файлове от хранилището, но не и от работната си среда!
Добавете `.gitignore` файл който да игнорира всички `.txt` файлове освен
`test.txt` и вашият текстови файл!
Игнорирайте файловете от папки със името `temp`!
Добавете неиндексираните файлове и качете нов комит!

## Връщане на промени

Команди за това упражнение:

```shell
git commit --amend
git restore
git reset
git revert
```

В собственият си клон добавете текст към текстовия си файл и направете нов
комит без да го качвате към сървъра!
Променете съдържанието на файла си и коментара на последния си комит с
`git commit --amend`!
Изтрийте всички файлове от хранилището си и направете нов комит
без да го качвате към сървъра!
Върнете се към предишния комит с `git reset` и качете промените си на сървъра!
Добавете нов ред към текстовия си файл, направете нов комит и го качете!
Върнете последните промени с `git revert` и качете новия комит!

## Сливане

Създайте нов клон `вашето-име-merge` и превключете към него!
Добавете нов ред към текстовия си файл и направете нов комит!
Превключете към основния си клон, добавете нов ред към текстовия си файл и
направете нов комит!
Слейте промените от новия клон с `git merge`!
Справете се с конфликтите и качете новия комит на сървъра!
Свалете последните промени от `master` на сървъра във вашия клон!
Заявете сливане на вашия клон към `master` чрез pull request!
Изтрийте слетите клонове от локалното си хранилище!
